# vim:filetype=sh
# set -x

declare -A ps1
declare -A icon

source ~/.local/bin/devicons.sh
source ~/.local/bin/powerline_icons.sh
source ~/.local/bin/materialdesign_icons.sh

icon[git]=$(echo -e ${dev[git_branch]})
icon[sep]=$(echo -e ${powerline[right_hard_divider]})
icon[keyboard]=$(echo -e ${md[keyboard]})

__git_info() {
    GIT_PS1_SHOWDIRTYSTATE=1
    GIT_PS1_SHOWSTASHSTATE=1
    GIT_PS1_SHOWUNTRACKEDFILES=1
    GIT_PS1_SHOWUPSTREAM="verbose name"

    local git_ps1
    if git_ps1=$(__git_ps1) && [[ -n $git_ps1 ]] ; then
        # Valid git repo. Set elements of array
        ps1_info[git]=1
        for word in ${git_ps1} ; do
            case $word in
                \(*)
                    ps1_info[git_branch]=${word:1}
                    ;;
                [^a-zA-Z]*)
                    [[ $word =~ '*' ]] && ps1_info[git_dirty]=1
                    [[ $word =~ [^u]\+ ]] && ps1_info[git_staged]=1
                    [[ $word =~  '$' ]] && ps1_info[git_stash]=1
                    [[ $word =~  '%' ]] && ps1_info[git_untracked]=1
                    ;;
                u*)
                    local sword=${word:1}
                    ps1_info[git_ahead]=$(expr "$sword" : '\(\+[0-9]*\)')
                    ps1_info[git_behind]=$(expr "$sword" : '.*\(\-[0-9]*\)')
                    ;;
                [a-zA-Z]*\))
                    ps1_info[git_remote]=${word%/*}
                    ;;
            esac
        done
    else
        ps1_info[git]=0
    fi
}

# TODO: battery

__prompt_collect_info() {
    local __RET=$?
    declare -A ps1_info
    if [[ $# == 1 ]] ; then
        local __RET=$1
    fi

    __git_info

    ps1[cpath]=${escapes[bold]}${escapes[fblB]}

    if [[ ${ps1_info[git]} == 1 ]] ; then
        ps1[prompt]=${icon[git]}
        ps1[git_branch]=${ps1_info[git_branch]}
    else
        ps1[prompt]="$"
        ps1[git_branch]=
    fi

    if [[ ${__RET} -ne 0 ]] ; then
        ps1[creturn]=${escapes[bold]}${escapes[freB]}
        if [[ ${__RET} == 130 ]] ; then
            ps1[return]="${icon[keyboard]} "
        else
            ps1[return]="${__RET} "
        fi
    else
        ps1[creturn]=
        ps1[return]=
    fi

}

__prompt() {
    __prompt_collect_info "$@"

    local PS1L PS1R

    # Set RHS prompt. This can include escape sequences.
    PS1R=""
    PS1R+="${escapes[fgrB]}${icon[sep]}${escapes[clear]}"
    PS1R+="${escapes[bgrB]}${escapes[fre]}${ps1[git_branch]}${escapes[clear]}"

    # Set LHS prompt.
    PS1L=" "
    PS1L+="\[${ps1[cpath]}\]\W\[${escapes[clear]} \]"
    PS1L+="\[${ps1[creturn]}\]${ps1[return]}\[${escapes[clear]}\]"
    PS1L+="${ps1[prompt]} "

    PS1="\[$(__prompt_rhs "${PS1R}")\]${PS1L}"
}

__prompt_timing() {
    local __RET=$?
    if [[ -n $DEBUG ]] ; then
        local time_start time_end time_used
        time_start=$(date +%s.%N)
        __prompt $__RET
        time_end=$(date +%s.%N)
        time_used=$(echo $time_end - $time_start | bc -l)
        echo $time_used | tee -a .PS1_timing
    else
        __prompt $__RET
    fi
}

# Time the execution of PROMPT_COMMAND?
PROMPT_COMMAND='__prompt_timing'

__prompt_rhs() {
    [[ $# != 1 ]] && return

    local rhs=$1
    local rhs_printable=${rhs//\[+([0-9]|;)m/}
    local length=${#rhs_printable}

    echo -e "$(tput sc; tput cuf $((COLUMNS - length)))${rhs}$(tput rc)"
}
